[{"content":"Image Histogram and Histogram Equalization Image historgram represents the intensity distribution of an image. X-axis stands for intensity, Y-axis for the number of pixels. Histogram equalization is a method in image processing of contrast adjustment using the image\u0026rsquo;s histogram 1. It stretches out the intensity range of the image.\nUse HSV Hue saturation value (HSV) color scale is used to process the intensity separately and to focus on value channel. Thus, I changed the image from BGR to HSV first, and equalized the histogram on value channel only, and finally converted the image from HSV to RGB.\n# preprocess the image backyard = cv2.imread(F\u0026#39;/content/gdrive/My Drive/Colab Notebooks/ComputerVision/beach.jpg\u0026#39;) backyard_rgb = cv2.cvtColor(backyard, cv2.COLOR_BGR2RGB) # BGR -\u0026gt; RGB backyard_hsv = cv2.cvtColor(backyard, cv2.COLOR_BGR2HSV) # BGR -\u0026gt; HSV Images before and after equalization First image is A kid on the beach. After the equalization, overall image got darker, and color contrast enhanced (i.e. swimsuit and sand volcanoes)\n# Equlize Hitogram backyard_hsv[:,:,2] = cv2.equalizeHist(backyard_hsv[:,:,2]) # equalization backyard_eq_color = cv2.cvtColor(backyard_hsv, cv2.COLOR_HSV2RGB) # HSV -\u0026gt; RGB display_side(backyard_rgb, backyard_eq_color) # function to display two images side by side # for grey scale, make sure to set cmap to Greys or Greys_r def display_side(img1, img2, cmap_input=None): fig = plt.figure(figsize=(12, 10)) ax=fig.add_subplot(121) ax.imshow(img1, cmap=cmap_input) ax=fig.add_subplot(122) ax.imshow(img2, cmap=cmap_input) # draw histogram for the image color = {\u0026#39;b\u0026#39;, \u0026#39;g\u0026#39;, \u0026#39;r\u0026#39;} plt.subplot(1,2,1) for i, col in enumerate(color): histr = cv2.calcHist([backyard], [i], None, [256], [0,256]) plt.plot(histr,color=col) plt.title(\u0026#39;Histogram Before Equalization\u0026#39;) color = {\u0026#39;r\u0026#39;, \u0026#39;g\u0026#39;, \u0026#39;b\u0026#39;} plt.subplot(1,2,2) for i, col in enumerate(color): histr = cv2.calcHist([backyard_eq_color], [i], None, [256], [0,256]) plt.plot(histr,color=col) plt.title(\u0026#39;Histogram after Equalization\u0026#39;) plt.tight_layout() It works better with a greyscale image such as x-rays.\n# preprocess the image x_ray = cv2.imread(F\u0026#39;/content/gdrive/My Drive/Colab Notebooks/ComputerVision/x-ray.jpg\u0026#39;) x_ray_grey = cv2.cvtColor(backyard, cv2.COLOR_BGR2GRAY) # BGR -\u0026gt; GRAY # focus on value channel xray_eq = cv2.equalizeHist(x_ray_grey) # equalization display_side(x_ray, xray_eq, \u0026#34;Greys_r\u0026#34;) display_side(x_ray_grey, xray_eq, \u0026#34;Greys_r\u0026#34;) # draw histogram for grey image color = {\u0026#39;b\u0026#39;, \u0026#39;g\u0026#39;, \u0026#39;r\u0026#39;} plt.subplot(1,2,1) histr = cv2.calcHist(x_ray_grey, [0], None, [256], [0,256]) plt.title(\u0026#39;Histogram Before Equalization\u0026#39;) plt.plot(histr) plt.subplot(1,2,2) histr = cv2.calcHist(xray_eq, [0], None, [256], [0,256]) plt.title(\u0026#39;Histogram After Equalization\u0026#39;) plt.plot(histr) plt.tight_layout() Wikipedia on Histogram Equalization\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","permalink":"https://hchang18.github.io/posts/2023-03-14-histogram-equalizer/","summary":"Image Histogram and Histogram Equalization Image historgram represents the intensity distribution of an image. X-axis stands for intensity, Y-axis for the number of pixels. Histogram equalization is a method in image processing of contrast adjustment using the image\u0026rsquo;s histogram 1. It stretches out the intensity range of the image.\nUse HSV Hue saturation value (HSV) color scale is used to process the intensity separately and to focus on value channel. Thus, I changed the image from BGR to HSV first, and equalized the histogram on value channel only, and finally converted the image from HSV to RGB.","title":"Histogram Equalization"},{"content":"Perspective Transformation This is a photo of a paper on a table. Is there a way to make it look as if it was scanned, removing everything outside the paper? This is possible if we use prospective transformation that restores the image to a picture that is centered with the optical axis and does not contain any rotation, changes to aspect ratio, skew, or keystone distortion.\nThe picture is the letter sized paper, and thus aspect ratio is 8 x 11. We need to know the coordinates of four corners of the paper in the original image and the coordinates of desired shape of the output image (letter size). Then we calculate the coefficients of perspective transformation (3 x 3 matrix) and plug the matrix in to the warpPerspective function, which uses forwardWarp unless flagged in the function.\nThis is the 3 x 3 projective transform matrix for this case. The OpenCV Github lines 3252 - 3273 Why Projective Transformation Among several transformations available, translation, rigid, similarity, and affine transformations provide not enough degree of freedom to map trapazoid into rectangle.\npaper = cv2.imread(F\u0026#39;/content/gdrive/My Drive/Colab Notebooks/ComputerVision/paper.jpg\u0026#39;) paper = cv2.cvtColor(paper, cv2.COLOR_BGR2RGB) rows, cols, ch = paper.shape pts1 = np.float32([[500,1100],[1500,1100],[125,2350],[1950,2330]]) pts2 = np.float32([[0,0],[800,0],[0,1100],[800,1100]]) M = cv2.getPerspectiveTransform(pts1, pts2) print(M) dst = cv2.warpPerspective(paper, M, (800, 1100), cv2.WARP_INVERSE_MAP) display_side(img, dst) plt.subplot(121),plt.imshow(paper),plt.title(\u0026#39;Input\u0026#39;) plt.subplot(122),plt.imshow(dst),plt.title(\u0026#39;Output\u0026#39;) plt.show() ","permalink":"https://hchang18.github.io/posts/2023-03-14-perspective-transform/","summary":"Perspective Transformation This is a photo of a paper on a table. Is there a way to make it look as if it was scanned, removing everything outside the paper? This is possible if we use prospective transformation that restores the image to a picture that is centered with the optical axis and does not contain any rotation, changes to aspect ratio, skew, or keystone distortion.\nThe picture is the letter sized paper, and thus aspect ratio is 8 x 11.","title":"Perspective Transformation"},{"content":"Sobel Derivative and Custom Filter Sobel derivative calculates the derivative in x and y directions. Thus, I decided to create customized 2D filter to calculate the derivative in the direction of 45 and -45 degree angles, respectively.\nThe customized kernel for 45 degree is:\n$$ \\begin{bmatrix} 0 \u0026amp; 1 \u0026amp; 2 \\\\ -1 \u0026amp; 0 \u0026amp; 1 \\\\ -2 \u0026amp; -1 \u0026amp; 0 \\end{bmatrix} $$ The kernel for -45 degrees is:\n$$ \\begin{bmatrix} -2 \u0026amp; -1 \u0026amp; 0 \\\\ -1 \u0026amp; 0 \u0026amp; 1 \\\\ 0 \u0026amp; 1 \u0026amp; 2 \\end{bmatrix} $$ At each point of the image, we calculate the gradient in that point, by combining both results above. Take absolute value of gradients at 45 and at âˆ’45 degree angle, then weighted-average them to make the gradient\nConvolution operator is 3 x 3 as we need to calculate the difference between the neighboring cells, and border type was set as default (reflective).\n# import and convert the image into gray scale img = cv2.imread(F\u0026#39;/content/gdrive/.../myhouse.jpg\u0026#39;) img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB) # convolution operator to apply on the entire image matrix kernel_pos = np.array([[0,1,2],[-1,0,1],[-2, -1, 0]]) kernel_neg = np.array([[-2, -1, 0],[-1, 0, 1],[0, 1, 2]]) # calculate the grad with respect to 45 and -45 degrees grad_pos = cv2.filter2D(img,-1,kernel_pos) grad_neg = cv2.filter2D(img,-1,kernel_neg) # calculate into to make absolute values abs_grad_pos = cv2.convertScaleAbs(grad_pos) abs_grad_neg = cv2.convertScaleAbs(grad_neg) # calculate gradient of that point grad = cv2.addWeighted(abs_grad_pos, 0.5, abs_grad_neg, 0.5, 0) # show directional derivative fig = plt.figure(figsize=(12,10)) ax = fig.add_subplot(121) ax.imshow(img) ax = fig.add_subplot(122) ax.imshow(grad) Reference OpenCV Tutorials on Sobel Derivatives\n","permalink":"https://hchang18.github.io/posts/2023-03-07-directional-derivative/","summary":"Sobel Derivative and Custom Filter Sobel derivative calculates the derivative in x and y directions. Thus, I decided to create customized 2D filter to calculate the derivative in the direction of 45 and -45 degree angles, respectively.\nThe customized kernel for 45 degree is:\n$$ \\begin{bmatrix} 0 \u0026amp; 1 \u0026amp; 2 \\\\ -1 \u0026amp; 0 \u0026amp; 1 \\\\ -2 \u0026amp; -1 \u0026amp; 0 \\end{bmatrix} $$ The kernel for -45 degrees is:","title":"Directional Derivatives "},{"content":"Summary Read an image file and convert the image from one color space (e.g. BGR to RGB). Select the filter (e.g. Gaussian Kernel function or any custom filter) and apply to the image for smoothing effect. The bigger the kernel size, the blurrier an image will be. To sharpen the image, get the difference between original and blurred images and add back that difference with sharpened ratio of your choice. Getting Started with OpenCV # import libraries import cv2 import numpy as np import matplotlib.pyplot as plt %matplotlib inline # mount the google drive to get my image from google.colab import drive drive.mount(\u0026#39;/content/gdrive\u0026#39;) # Load the image and change color space def load_img(): img = cv2.imread(F\u0026#39;/content/gdrive/tiles.jpg\u0026#39;).astype(np.float32) / 255 img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB) return img def load_img_without_color_convert(): img = cv2.imread(F\u0026#39;/content/gdrive/tiles.jpg\u0026#39;).astype(np.float32) / 255 return img Open CV color was formatted in blue-green-red(BGR), so the image is convered to red-green-blue(RGB) scheme to show the image in a way human perceives the color.\n# Display one image def display_img(img): fig = plt.figure(figsize=(12,10)) ax = fig.add_subplot(111) ax.imshow(img) # Display two images side by side def display_side(img1, img2): fig = plt.figure(figsize=(12, 10)) ax=fig.add_subplot(121) ax.imshow(img1) ax=fig.add_subplot(122) ax.imshow(img2) # Call the function and load the image img = load_img() How to Blur an Image Gaussian kernel function is used to smoothe the image. The aspect ratio of the image is H: 2880, W: 2160, and the kernel function was applied to all three color channels.\n# Gaussian Kernel blurred_backyard = cv2.GaussianBlur(img,ksize=(15,15), / sigmaX=10, sigmaY=10, borderType=4) display_side(img, blurred_backyard) As Kernel size increases, the image blurs more. Given the large image size (2160 by 2880), a small sized kernels such as 3 x 3 and 5 x 5 did not effectively blur the image. The kernel size of 31 x 31 delivered a clear blurring effect for this image. The sigma values in the Gaussian filter implies that there are some variation around its mean value. The larger the sigma values in both x and y, the blurrier an image gets.\nThe left is the original image and the right is the one after smoothing.\nFor the border, reflective border type was chosen. This is because the image showed my backyard and it was safe to assume similar pattern continues (fence, tree, and nextdoor house) beyond what\u0026rsquo;s showing on the image.\n# other kenel functions dst_blur = cv2.blur(img, ksize=(15,15), borderType=4) # median blurring dst_median = cv2.medianBlur(img,5) Note that median blurring is highly effective to remove salt-and-pepper noise in an image.\nHow to Sharpen the Image Unsharp masking from darkroom photography Sharpening calculates the difference between the original image and blurred image and adds the difference back to the original image. After all, both images are 2D matrices of the same size.\nSharpened image = original + sharpened_force x (original - blurred) difference = img - blurred_backyard display_side(img, difference) The right image shows boundaries between objects. Lines are more obvious where contrasting colors are facing each other, like the light grey air conditioner unit and the brown backyard door. The difference is even clearer when multiplied by sharpenend_force. In this case, I set sharpened_force at x3 to give a striking difference.\n# Unsharp masking (sharpening the image) # sharp_background = original + (original - blurred) * sharpen_force sharpen_force = 3 sharp_backyard = img + sharpen_force * difference display_side(img, sharp_backyard) Or we can use sharpen filter derived from the unsharp masking. The image is convolved with the sharpen filter to make the image more clear.\nkernel = np.array([[0, -1, 0], [-1, 5, -1], [0, -1, 0]]) sharp_backyard2 = cv2.filter2D(img, ddepth=-1, kernel=kernel) display_side(img, sharp_backyard2) ","permalink":"https://hchang18.github.io/posts/2023-03-01-how-to-smooth-and-sharpen-image/","summary":"Summary Read an image file and convert the image from one color space (e.g. BGR to RGB). Select the filter (e.g. Gaussian Kernel function or any custom filter) and apply to the image for smoothing effect. The bigger the kernel size, the blurrier an image will be. To sharpen the image, get the difference between original and blurred images and add back that difference with sharpened ratio of your choice. Getting Started with OpenCV # import libraries import cv2 import numpy as np import matplotlib.","title":"How to Blur and Sharpen Color Image"},{"content":"This is Haeyoon.\n","permalink":"https://hchang18.github.io/about/","summary":"This is Haeyoon.","title":"About Me"}]